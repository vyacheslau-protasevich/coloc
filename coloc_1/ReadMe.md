# Вариант 4 1.4, 2.6, 2.8, 2.11, 2.1, 3.2, 3.5, 3.8, 3.12, 4.2, 5.1, 6.1


### Оглавление:
- [Шаблон проектирования Builder](1.4)
- [2.6](#2.6)
- [2.8](#2.8)
- [2.11](#2.11)
- [2.1](#2.1)
- [3.2](#3.2)
- [3.5](#3.5)
- [3.8](#3.8)
- - [3.12](#3.12)
- - [4.2](#4.2)
- - [5.1](#5.1)
- - [6.1](#6.1)


<a id="1.4"></a>
# 1.4
### Шаблон проектирования Builder: 

**Шаблон проектирования Builder (Строитель)** — это порождающий шаблон, который позволяет конструировать сложные объекты шаг за шагом. Он позволяет создавать различные виды объектов, используя один и тот же код строительства.

### Ключевые компоненты Builder Design Pattern:

1. **Product (Продукт)**: Конечный объект, который будет создан шаблоном Builder.

2. **Builder (Строитель)**: Интерфейс или абстрактный класс для пошагового создания продукта.

3. **ConcreteBuilder (Конкретный строитель)**: Реализация интерфейса Builder. Он определяет конкретные шаги построения продукта.

4. **Director (Директор)**: Отвечает за порядок вызова шагов строительства. Может знать больше о том, как создавать сложные объекты.

### "Псевдо" UML диаграмма Builder Pattern:

```
+----------------+       +------------------------+
|   Director     |<>---->|     Builder            |
+----------------+       +------------------------+
| Construct()    |       | BuildPart1()           |
| SetBuilder()   |       | BuildPart2()           |
+----------------+       | GetResult(): Product   |
                         +------------------------+
                                   ^
                                   |
                                   |
                         +----------------------+
                         |   ConcreteBuilder    |
                         +----------------------+
                         | BuildPart1()         |
                         | BuildPart2()         |
                         | GetResult(): Product |
                         +----------------------+
                                   ^
                                   |
                                   |
                         +-------------------+
                         |      Product      |
                         +-------------------+
                         | Part1             |
                         | Part2             |
                         +-------------------+
```

### Аспекты инкапсуляции в Builder Pattern:

**1. Детали конструирования скрыты**: Клиентский код не знает о внутренних деталях создания объекта. Он работает с интерфейсом строителя.

**2. Конструирование сложного объекта инкапсулировано**: Логика конструирования сложных объектов находится внутри конкретных строителей.

### Аспекты изменчивости и сложности в Builder Pattern:

**1. Изменение внутреннего представления продукта не влияет на клиентский код**: Если внутреннее представление продукта изменится, это не повлияет на клиентский код, так как он работает с интерфейсом строителя.

**2. Добавление новых типов продуктов и строителей**: Можно легко добавить новые типы продуктов и соответствующие строители без изменения существующего кода клиента.

### Пример использования Builder Pattern:

Предположим, у нас есть класс `Computer`, который имеет множество параметров, таких как процессор, RAM, жесткий диск и т.д. С Builder Pattern мы можем создать различные виды компьютеров, используя один и тот же код строительства:

```css
class Computer {
    // properties
};

class ComputerBuilder {
public:
    virtual void setProcessor() = 0;
    virtual void setRAM() = 0;
    virtual void setHardDisk() = 0;
    virtual Computer getResult() = 0;
};

class HighEndComputerBuilder : public ComputerBuilder {
    // implementation for setting up a high-end computer
};

class LowEndComputerBuilder : public ComputerBuilder {
    // implementation for setting up a low-end computer
};

class Director {
public:
    Computer construct(ComputerBuilder* builder) {
        builder->setProcessor();
        builder->setRAM();
        builder->setHardDisk();
        return builder->getResult();
    }
};

int main() {
    Director director;
    HighEndComputerBuilder highEndBuilder;
    LowEndComputerBuilder lowEndBuilder;

    Computer highEndComputer = director.construct(&highEndBuilder);
    Computer lowEndComputer = director.construct(&lowEndBuilder);

    // highEndComputer and lowEndComputer are ready to use
    return 0;
}
```

В этом примере `Director` знает, какую последовательность шагов нужно выполнить для построения компьютера, но не знает о конкретных типах компьютеров или их внутреннем представлении. Клиентский код может создавать различные виды компьютеров, не зная подробностей их конструирования.




<a id="2.6"></a>
# 2.6
**Полиморфизм** - это один из ключевых принципов объектно-ориентированного программирования, который позволяет объектам различных классов обрабатываться как объекты одного и того же базового класса. Это означает, что объекты разных типов могут быть обработаны с использованием одного и того же интерфейса, что облегчает создание более гибкого и удобного для понимания кода.

### Истинный полиморфизм:

1. **Полиморфизм во время выполнения (Run-time Polymorphism)**: Это тип полиморфизма, который происходит во время выполнения программы. Используется механизм виртуальных функций (в языках программирования, таких как C++ и Java) или интерфейсов (в языках, таких как Java и C#). Когда функция вызывается через указатель или ссылку на базовый класс, она может выполняться как функция производного класса, к которому указывает указатель или ссылка. Такой подход позволяет достичь истинного полиморфизма.

Пример в C++:

```cpp
class Shape {
public:
    virtual void draw() {
        // реализация базового класса
    }
};

class Circle : public Shape {
public:
    void draw() override {
        // реализация производного класса
    }
};

int main() {
    Shape* shape = new Circle();
    shape->draw(); // вызовет функцию draw() класса Circle
    delete shape;
    return 0;
}
```

В этом примере, `shape` - это указатель на объект типа `Shape`, который фактически указывает на объект типа `Circle`. При вызове `shape->draw()`, будет вызвана функция `draw()` из класса `Circle`.

### "Псевдо" полиморфизм:

1. **Полиморфизм во время компиляции (Compile-time Polymorphism)**: Это тип полиморфизма, который определяется на этапе компиляции программы. В языках программирования, таких как C++, это достигается с использованием перегрузки функций и операторов. В перегрузке функций имена функций могут быть одинаковыми, но их параметры должны отличаться (по типу или количеству). Компилятор выбирает подходящую функцию для вызова на основе типа аргументов.

Пример в C++:

```cpp
#include <iostream>

void print(int x) {
    std::cout << "Это целое число: " << x << std::endl;
}

void print(double y) {
    std::cout << "Это число с плавающей точкой: " << y << std::endl;
}

int main() {
    print(5);      // вызывает функцию print(int)
    print(3.14);   // вызывает функцию print(double)
    return 0;
}
```

В этом примере, функция `print()` перегружена для работы с различными типами данных (целыми числами и числами с плавающей точкой). Компилятор определяет, какую функцию вызывать, на основе типа аргумента, переданного в функцию.

Таким образом, "псевдо" полиморфизм достигается за счет перегрузки функций и операторов на этапе компиляции, в отличие от "истинного" полиморфизма, который происходит во время выполнения программы.






<a id="2.8"></a>
# 2.8
**Абстрагирование** в контексте объектно-ориентированного программирования (ООП) - это процесс создания абстрактных представлений объектов и операций для работы с ними. Оно позволяет скрыть сложность деталей реализации и предоставить упрощенный интерфейс для взаимодействия с объектами. В ООП абстрагирование позволяет создавать абстрактные классы и интерфейсы, определяя только необходимую функциональность, без конкретной реализации.

**Гради Буч** представил абстрагирование как четвертый принцип объектно-ориентированного программирования, известный как **"Абстрагирование"** или **"Абстракция"**. Этот принцип важен, потому что он обеспечивает создание абстрактных классов и интерфейсов, которые служат основой для создания конкретных объектов и классов. Путем абстрагирования программисты могут выделять общие характеристики и поведение объектов и создавать унифицированные интерфейсы для работы с ними.

Принцип абстрагирования позволяет:

1. **Упрощение сложности**: Путем абстрагирования программисты могут скрыть детали реализации, фокусируясь на ключевых аспектах объекта.

2. **Сокрытие деталей реализации**: Пользователи могут взаимодействовать с объектами, используя только определенные методы, не зная, как эти методы реализованы внутри объекта.

3. **Создание общего интерфейса**: Абстрактные классы и интерфейсы определяют общие методы, которые должны быть реализованы в подклассах, обеспечивая единый способ работы с различными типами объектов.

4. **Повышение уровня абстракции**: Программисты могут работать на более абстрактном уровне, концентрируясь на общих характеристиках и поведении объектов, без необходимости вникать в детали их реализации.

Путем использования абстракции программисты могут создавать гибкие, поддерживаемые и масштабируемые программы, упрощая процесс разработки и обеспечивая повышенную читаемость и понимание кода.




<a id="2.11"></a>
# 2.11

Процедурное программирование до сих пор применяется по нескольким причинам:

1. **Легкость освоения и понимания**: Процедурное программирование является более простым для понимания и изучения, особенно для начинающих программистов. Оно предоставляет простые и ясные конструкции управления, такие как последовательность, условия и циклы.

2. **Производительность**: В некоторых случаях процедурное программирование может быть более эффективным с точки зрения производительности. Некоторые задачи могут быть реализованы более эффективно и быстро с использованием простых процедурных подходов, чем с применением сложных объектно-ориентированных методов.

3. **Совместимость с низкоуровневым программированием**: Некоторые задачи, особенно в области встроенных систем и разработки драйверов, требуют непосредственного управления аппаратурой. Процедурное программирование лучше подходит для таких низкоуровневых задач.

4. **Существующий код и ресурсы**: Существует огромное количество проектов, написанных на процедурных языках, и многие из них продолжают использоваться и обновляться. Переписывание всех этих проектов на объектно-ориентированный манер требует значительных усилий и ресурсов, что не всегда оправдано.

5. **Компромисс между сложностью и производительностью**: В некоторых случаях процедурный стиль программирования предоставляет хороший баланс между сложностью кода и производительностью программы. В некоторых задачах использование объектно-ориентированных подходов может привести к избыточной сложности.

6. **Специфические требования отрасли**: В некоторых отраслях, таких как финансы и банки, существует множество старых систем и приложений, написанных на процедурных языках. Эти системы работают стабильно и должны поддерживаться, независимо от их устаревшего подхода к программированию.

В целом, хотя объектно-ориентированное программирование (ООП) стало доминирующим стилем программирования, процедурное программирование все еще имеет свое место, особенно в контексте некоторых конкретных задач и проектов.




<a id="2.1"></a>
# 2.1
**Процедурная декомпозиция** - это методология разработки программ, при которой программа разбивается на более мелкие и управляемые части, называемые процедурами (или функциями), чтобы упростить анализ, проектирование и поддержку программного кода. Это означает, что большая и сложная задача делится на более мелкие подзадачи, которые могут быть легче решены независимо друг от друга.

Процедурная декомпозиция позволяет повысить читаемость, понимание и поддержку кода, делая программу более модульной и управляемой.

### Примеры процедурной декомпозиции:

#### 1. **Калькулятор**

Задача: Написать калькулятор, который может выполнять базовые арифметические операции (сложение, вычитание, умножение, деление).

Процедуры:
- `add(a, b)`: сложение двух чисел.
- `subtract(a, b)`: вычитание одного числа из другого.
- `multiply(a, b)`: умножение двух чисел.
- `divide(a, b)`: деление одного числа на другое.

Процедурная декомпозиция в этом случае позволяет разделить разные операции на отдельные функции, что делает код более читаемым и легко управляемым.

#### 2. **Управление Сотрудниками**

Задача: Реализовать систему управления данными о сотрудниках в организации.

Процедуры:
- `addEmployee(name, id, position)`: добавить нового сотрудника в базу данных.
- `removeEmployee(id)`: удалить сотрудника из базы данных по идентификационному номеру.
- `updateEmployee(id, field, value)`: обновить информацию о сотруднике (имя, должность, и т.д.).
- `getEmployeeDetails(id)`: получить подробную информацию о сотруднике.

Здесь процедурная декомпозиция позволяет выделить различные операции с данными сотрудников в отдельные процедуры, что делает код более управляемым и модульным.

В обоих примерах процедурная декомпозиция позволяет разбить сложные задачи на более простые подзадачи, делая программу более понятной и легкой для разработки и поддержки.





<a id="3.2"></a>
# 3.2
**Цикломатическая сложность** - это метрика, используемая для измерения сложности программы. Она представляет собой количественную меру различных путей исполнения в программе. Чем больше путей, тем сложнее программа и, вероятно, тем больше тестовых случаев требуется для полного тестирования.

Цикломатическая сложность определяется по формуле:

\[ V(G) = E - N + 2P \]

Где:
- \( V(G) \) - цикломатическая сложность.
- \( E \) - количество рёбер в графе потока управления.
- \( N \) - количество узлов (вершин) в графе потока управления.
- \( P \) - количество связанных компонентов (частей графа, связанных друг с другом, но не связанных с остальной частью).

Цикломатическая сложность помогает оценить количество тестовых случаев, которые необходимы для полного покрытия всех возможных путей выполнения программы. Чем выше цикломатическая сложность, тем больше путей существует в программе, и тем больше тестов нужно написать, чтобы проверить все эти пути.

Большая цикломатическая сложность может указывать на:
- Сложные функции или методы, которые трудно поддается анализу и тестированию.
- Программный код, который, возможно, нуждается в рефакторинге для улучшения его читаемости и управляемости.

Существует также концепция "предела цикломатической сложности", обычно рекомендуемого максимального значения цикломатической сложности для упрощения тестирования и обслуживания программы. Различные источники могут рекомендовать разные значения этого предела, обычно оно находится в диапазоне от 10 до 15. Если цикломатическая сложность превышает этот предел, программисты могут рассмотреть возможность упрощения функций или методов для снижения сложности программы.






<a id="3.8"></a>
# 3.5

**Unit тестирование** - это процесс проверки отдельных модулей (или компонентов) программы для обеспечения их корректности. В контексте объектно-ориентированного программирования, модуль может быть классом, функцией, методом и так далее. Целью unit тестирования является проверка того, что каждая часть программы работает так, как предполагается.

### Три варианта использования unit тестов:

1. **Проверка функциональности**: Unit тесты используются для проверки корректности отдельных функций или методов. Например, если у вас есть функция, которая вычисляет сумму двух чисел, вы можете написать unit тест, который передает этой функции различные входные значения и проверяет, возвращает ли она правильные результаты.

   ```python
   def test_sum():
       assert sum(1, 2) == 3
       assert sum(-1, 1) == 0
       assert sum(0, 0) == 0
   ```

2. **Обеспечение стабильности кода**: Unit тесты могут быть использованы для обнаружения ошибок и непредвиденного поведения при внесении изменений в код. После внесения изменений, unit тесты запускаются для проверки, не повлияли ли эти изменения на корректность работы уже существующего кода.

   ```python
   def test_division():
       assert divide(1, 2) == 0.5
       assert divide(1, 0) == 'Error: Division by zero'
   ```

3. **Документирование функциональности**: Хорошие unit тесты могут служить документацией к функциям и методам, объясняя, как они должны вести себя и какие результаты ожидать. Читая тесты, разработчики могут легко понять, как использовать определенные части кода.

   ```python
   def test_string_concatenation():
       assert concatenate_strings('Hello', 'World') == 'Hello World'
       assert concatenate_strings('Open', 'AI') == 'Open AI'
   ```

Примечание: Приведенные примеры написаны на языке Python и используют структуру тестов из библиотеки pytest. В других языках программирования существуют аналогичные инструменты для написания и запуска unit тестов. Unit тестирование - это важная часть практики разработки программного обеспечения, так как оно помогает убедиться в правильности функционирования отдельных компонентов программы и их взаимодействия.






<a id="3.8"></a>
# 3.8
**Mock Framework**, или библиотека моков (Mocking framework), - это инструмент в тестировании программного обеспечения, который позволяет создавать "поддельные" (mock) объекты и функции для замены реальных компонентов системы, с которыми тестируемый компонент взаимодействует. Такие поддельные объекты создаются с целью имитации поведения реальных объектов или функций в контролируемой среде, что делает тестирование более предсказуемым и управляемым.

### Случаи, когда необходимо использовать моки:

1. **Тестирование внешних зависимостей**: Когда программа взаимодействует с внешними ресурсами, такими как базы данных, веб-сервисы или API, использование моков позволяет изолировать тестируемый компонент от этих внешних систем, делая тесты более быстрыми и предсказуемыми.

2. **Тестирование компонентов, еще не реализованных или недоступных**: Когда разрабатывается часть системы, которая зависит от компонентов, еще не реализованных или недоступных для тестирования, моки могут быть использованы для имитации поведения этих компонентов.

3. **Тестирование исключительных ситуаций**: Моки могут быть использованы для создания ситуаций, которые трудно или невозможно воспроизвести в реальных условиях. Например, тестирование обработки ошибок, которые сложно воссоздать в реальной базе данных.

4. **Тестирование распределенных систем**: Когда система состоит из множества распределенных компонентов, использование моков позволяет изолировать и тестировать отдельные компоненты независимо друг от друга. Это особенно полезно при тестировании микросервисных архитектур.

Использование моков упрощает создание управляемых и надежных тестов, делая их менее зависимыми от внешних факторов и обеспечивая большую предсказуемость результатов.






<a id="3.12"></a>
# 3.12
**Fluent Interface** (также известный как **Method Chaining**) - это паттерн проектирования, который позволяет создавать более выразительные и читаемые API, делая цепочки вызовов методов более понятными и естественными. Этот стиль позволяет вызывать методы последовательно, цепляя один вызов за другим, что приводит к удобочитаемому и легко понимаемому коду.

Пример Fluent Interface в языке программирования Java:

```java
public class FluentPerson {
    private String name;
    private int age;
    
    public FluentPerson name(String name) {
        this.name = name;
        return this;
    }
    
    public FluentPerson age(int age) {
        this.age = age;
        return this;
    }
    
    public void printInfo() {
        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
    }
}

public class Main {
    public static void main(String[] args) {
        FluentPerson person = new FluentPerson()
            .name("John")
            .age(30);
        person.printInfo();
    }
}
```

В контексте **Mock frameworks**, Fluent Interface может быть использован для создания моков более наглядным способом. Fluent Interface позволяет последовательно определить поведение мока, цепляя вызовы методов, определяющих, что делать при вызове определенных методов.

Пример Fluent Interface для мокирования с использованием библиотеки Mockito (на языке Java):

```java
import static org.mockito.Mockito.*;

public class ExampleTest {
    @Test
    public void testSomething() {
        // Создаем мок объект
        SomeClass mock = mock(SomeClass.class);
        
        // Определяем поведение мока с использованием Fluent Interface
        when(mock.method1()).thenReturn(value1)
            .thenThrow(new RuntimeException())
            .thenReturn(value2);
        
        // Вызываем методы мока
        assertEquals(value1, mock.method1());
        assertThrows(RuntimeException.class, () -> mock.method1());
        assertEquals(value2, mock.method1());
    }
}
```

В этом примере `when(mock.method1())` возвращает Fluent Interface, который позволяет определить последовательные действия для метода `method1()`. Это делает код тестов более понятным и легким для чтения, поскольку цепочка вызовов отражает последовательность ожидаемых событий.





<a id="4.2"></a>
# 4.2







<a id="5.1"></a>
# 5.1
Конечно, вот пример реализации абстрактной фабрики на языке программирования Python:

Сначала определим интерфейсы продуктов и фабрик:

```python
# Абстрактные продукты
class ProductA:
    def display(self):
        pass

class ProductB:
    def display(self):
        pass

# Абстрактная фабрика
class AbstractFactory:
    def create_product_a(self) -> ProductA:
        pass

    def create_product_b(self) -> ProductB:
        pass
```

Затем создадим две конкретные фабрики и их соответствующие продукты:

```python
# Конкретные продукты
class ConcreteProductA1(ProductA):
    def display(self):
        return "Concrete Product A1"

class ConcreteProductA2(ProductA):
    def display(self):
        return "Concrete Product A2"

class ConcreteProductB1(ProductB):
    def display(self):
        return "Concrete Product B1"

class ConcreteProductB2(ProductB):
    def display(self):
        return "Concrete Product B2"

# Конкретная фабрика 1
class ConcreteFactory1(AbstractFactory):
    def create_product_a(self) -> ProductA:
        return ConcreteProductA1()

    def create_product_b(self) -> ProductB:
        return ConcreteProductB1()

# Конкретная фабрика 2
class ConcreteFactory2(AbstractFactory):
    def create_product_a(self) -> ProductA:
        return ConcreteProductA2()

    def create_product_b(self) -> ProductB:
        return ConcreteProductB2()
```

Теперь мы можем написать unit-тесты, используя библиотеку pytest:

```python
import pytest

def test_abstract_factory():
    # Создаем фабрику 1 и производим продукты
    factory1 = ConcreteFactory1()
    productA1 = factory1.create_product_a()
    productB1 = factory1.create_product_b()

    assert productA1.display() == "Concrete Product A1"
    assert productB1.display() == "Concrete Product B1"

    # Создаем фабрику 2 и производим продукты
    factory2 = ConcreteFactory2()
    productA2 = factory2.create_product_a()
    productB2 = factory2.create_product_b()

    assert productA2.display() == "Concrete Product A2"
    assert productB2.display() == "Concrete Product B2"
```

В этом примере мы создали две конкретные фабрики (ConcreteFactory1 и ConcreteFactory2), каждая из которых создает свои продукты (ConcreteProductA1, ConcreteProductA2, ConcreteProductB1 и ConcreteProductB2). Затем мы написали unit-тесты для проверки, что каждая фабрика создает правильные продукты. Убедитесь, что у вас установлен pytest для запуска тестов.






<a id="6.1"></a>
# 6.1
