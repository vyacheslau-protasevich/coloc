Протасевич Вячеслав, 7 группа 2 курс

# Оглавление:
- [нулевая группа вопросов](#item-one)
- [первая группа вопросов](#item-two)
- [вторая группа вопросов](#item-three)
- [третья группа вопросов](#item-four)

<a id="item-one"></a>
# Нулевая группа вопросов


<h3>1. Процесс в ОС Windows:</h3>

   Процесс - это запущенная программа на компьютере. Каждая программа, запускается в своем процессе. Каждый процесс имеет свою область памяти и ресурсы, что обеспечивает изоляцию данных и повышает стабильность системы.

<h3>2. Критическая секция:</h3>

   Это часть программы, которая обеспечивает безопасный доступ к общим данным при параллельном выполнении задач. Когда один поток входит в критическую секцию, другие ждут, пока он не закончит работу, чтобы избежать конфликтов данных.

<h3>3. Семафор:</h3>

   Семафор - это инструмент, который помогает потокам взаимодействовать друг с другом. Он позволяет потокам контролировать доступ к общим ресурсам. Если семафор равен нулю, потоки могут ждать, пока он не станет больше нуля, что предотвращает конфликты при обращении к общим данным.

<h3>4. Сравнение C++98 с и без Boost (в контексте лабораторных работ):</h3>
   Boost представляет готовые решения для более сложных структур данных и функций, упрощая разработку. Не использование Boost помогает понять основы языка и алгоритмические концепции.</p>
<a id="item-two"></a>
# Первая группа вопросов

  Код для задач лежит в папке block_1, nunit тесты в подпапке tests
<a id="item-three"></a>
# Вторая группа вопросов

<h3>1. Процедурная декомпозиция:</h3>

  Процедурная декомпозиция - это методология в программировании, при которой большая задача разбивается на более мелкие подзадачи или процедуры. Это позволяет управлять сложными проблемами, разделяя их на более простые, понятные части. Процедурная декомпозиция способствует легкости понимания, разработки и управления кодом, делая программы более структурированными и поддерживаемыми.

<h3>2. Динамический полиморфизм:</h3>

  Динамический полиморфизм - это концепция объектно-ориентированного программирования, позволяющая объектам разных классов обрабатывать запросы одним и тем же способом. Это достигается через переопределение методов в классах наследниках. Во время выполнения программы, система определяет, какой метод вызывать, исходя из типа объекта, что обеспечивает гибкость и расширяемость программы.

<h3>3. Инкапсуляция:</h3>

  Инкапсуляция - это принцип объектно-ориентированного программирования, который позволяет объединить данные и методы, работающие с этими данными, в единый объект. Она ограничивает доступ к данным объекта извне, предоставляя интерфейс (методы) для взаимодействия с этими данными. Инкапсуляция обеспечивает безопасность данных, предотвращая их случайное изменение, и позволяет скрывать сложность реализации, облегчая использование объектов в программе.
<a id="item-four"></a>
# Третья группа вопросов

<h3>1. Singleton Pattern:</h3>

  Singleton - это порождающий паттерн проектирования, который гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. Это достигается путем скрытия конструктора класса и предоставления статического метода для получения его единственного экземпляра. Этот паттерн обеспечивает глобальную точку доступа к объекту, при этом контролирует его создание и убеждается, что создается только один экземпляр.
  
  Пример на Python:
  ```python
class Singleton:
   _instance = None
   
   def __new__(cls):
     if cls._instance is None:
         cls._instance = super(Singleton, cls).__new__(cls)
         # Логика класса
     return cls._instance

# Пример использования
singleton1 = Singleton()
singleton2 = Singleton()

print(singleton1 is singleton2)  # Выводит True, потому что это один и тот же объект
```

<h3>2. State Pattern:</h3>

  State - это поведенческий паттерн проектирования, который позволяет объекту изменять свое поведение при изменении его внутреннего состояния. Паттерн State выделяет каждое состояние объекта в отдельный класс и делегирует всякое поведение объекта классам состояний, представляя тем самым объект как объект конечного автомата.
  
  Пример на Python:
```python
class OrderState:
    def process_order(self):
        pass

class NewState(OrderState):
    def process_order(self):
        print("Processing new order")

class ShippedState(OrderState):
    def process_order(self):
        print("Order has been shipped")

class DeliveredState(OrderState):
    def process_order(self):
        print("Order has been delivered")

class Order:
    def __init__(self):
        self.state = NewState()

    def set_state(self, state):
        self.state = state

    def process_order(self):
        self.state.process_order()

# Пример использования
order = Order()
order.process_order()  # Вывод: Processing new order

order.set_state(ShippedState())
order.process_order()  # Вывод: Order has been shipped

order.set_state(DeliveredState())
order.process_order()  # Вывод: Order has been delivered
```